void printPath(int v, vector<int>& parent) {
    if (v == -1) return;
    printPath(parent[v], parent);
    cout << v << " ";
}

void Dijkstra(Graph g, int startNode) {
    int n = g.getAdjList().size();
    vector<vector<pair<int, int>>> adj = g.getAdjList();

    vector<int> dist(n, INT_MAX);
    vector<bool> visited(n, false);
    vector<int> parent(n, -1);

    dist[startNode] = 0;

    for (int i = 0; i < n; i++) {
        int u = -1, minDist = INT_MAX;
        for (int j = 0; j < n; j++) {
            if (!visited[j] && dist[j] < minDist) {
                minDist = dist[j];
                u = j;
            }
        }
        if (u == -1) break;
        visited[u] = true;

        for (auto edge : adj[u]) {
            int v = edge.first;
            int w = edge.second;
            if (!visited[v] && dist[v] > dist[u] + w) {
                dist[v] = dist[u] + w;
                parent[v] = u;
            }
        }
    }

    cout << "\nDijkstra (co duong di):\n";
    for (int i = 0; i < n; i++) {
        if (dist[i] == INT_MAX) {
            cout << "Khong co duong tu " << startNode << " den " << i << endl;
        }
        else {
            cout << "Tu " << startNode << " den " << i
                << " (do dai = " << dist[i] << "): ";
            printPath(i, parent);
            cout << endl;
        }
    }
}
struct Edge {
    int to;
    int cap;
};

vector<Edge> edges;
vector<vector<int>> graphFF;
vector<bool> visitedFF;

void addEdgeFF(int u, int v, int cap) {
    edges.push_back({ v, cap });
    edges.push_back({ u, 0 });
    graphFF[u].push_back(edges.size() - 2);
    graphFF[v].push_back(edges.size() - 1);
}

int dfsFF(int u, int t, int flow) {
    if (u == t) return flow;
    visitedFF[u] = true;

    for (int id : graphFF[u]) {
        if (!visitedFF[edges[id].to] && edges[id].cap > 0) {
            int pushed = dfsFF(edges[id].to, t,
                min(flow, edges[id].cap));
            if (pushed > 0) {
                edges[id].cap -= pushed;
                edges[id ^ 1].cap += pushed;
                return pushed;
            }
        }
    }
    return 0;
}

int FordFulkerson(int n, int s, int t) {
    int maxFlow = 0;
    while (true) {
        visitedFF.assign(n, false);
        int flow = dfsFF(s, t, INT_MAX);
        if (flow == 0) break;
        maxFlow += flow;
    }
    return maxFlow;
}
int main() {
    Graph g(5);

    g.addEdge(0, 1, 4);
    g.addEdge(0, 2, 2);
    g.addEdge(1, 2, 1);
    g.addEdge(1, 3, 5);
    g.addEdge(2, 3, 8);
    g.addEdge(3, 4, 3);

    BFS(g, 0);
    DFS(g, 0);

    Dijkstra(g, 0);

    int n = 4;
    graphFF.assign(n, vector<int>());
    edges.clear();

    addEdgeFF(0, 1, 3);
    addEdgeFF(0, 2, 2);
    addEdgeFF(1, 2, 1);
    addEdgeFF(1, 3, 2);
    addEdgeFF(2, 3, 4);

    cout << "\nMax Flow = " << FordFulkerson(n, 0, 3) << endl;

    return 0;
}
